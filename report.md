<<<<<<< HEAD
Nearest Neighbor
-----------------
For each pixel in the image, I divided the image in the new resampled image by the number it is being scaled by to get the nearest neighbor. Then I assigned it's intensity to the resampled image's pixel. Note, I did not use or write code for the interpolation functions in the interpolation.py file. The more the image is scaled by, the fuzzier the details for the image get and their is more pixelation in the image. 

Bilinear Interpolation
----------------------
When writing this function, I did not write code in the interpolation.py file. I instead wrote all the code within the bilinear_interpolation function itself. Using the functions and equations in the class lecture, I first found the two interpolations between the x-values in the 4-neighbors I calculated (where each neighbor is either the pixel before or after the output image's current pixel on either the x or y axis). After calculating those, I found the final interpolation between the 4-neighbors to get the intensity for the output image's pixel and assigned it. The runtime for larger images takes more time here than it did for Nearest Neighbor but gives a clearer image when resizing by larger scales. 

Histogram, Thresholding, Binarizing Image
-----------------------------------------
For the histogram, all I did was iterate through each image, record its intensity, then for each intensity add one. For my list, the intensity itself acts as the index to make recording intensity totals much easier. 

For the threshold, I averaged the two modes found within the image. To find the two modes, I assigned the first mode to the largest mode. Then for the second I got the modes both before and after the second mode. Then I compared to the two to get the overall second mode. After averaging the two modes, I used that as my temporary threshold. I then calculated my expected values for all values up until the threshold hold and the expected values from my threshold value until the highest value. To calculate the expected value, I had to to divide each number in my histogram by the total number of intensities in it then multiplied it by the actual intensity value. Then I averaged the two numbers to get another threshold, repeating this process of expected values and averaging until average no longer changed. That value is my final threshold value. 

For binarize, the only thing I saw being passed was the image so in the function I recalculated the histogram and the threshold value by copy+pasting my code from the Histogram and THresholding functions above. After that, I wanted to make sure no matter what, the binary image I ended up with where white polygons against a black background to make writing the region counting code easier. So if the mode of an image was larger than the threshold value, I know I have lighter images against a darker background so I made anything lower than the threshold white and anything darker black. If the mode was smaller than the threshold, then I have darker images against a lighter background so anything above the threshold is white and anything darker is black. 

Region Counting
-----------------
For region counting, I had some trouble doing blob coloring but after taking sometime I got it to work. For each of my images, since my polygons are white, I accounted for the current pixel being compared as always white. In my code, I have the value >0 just to account for any intensity that isn't black (since that will always be the background image). The function takes a very long time with larger images (such as the cell2.jpg file), taking anywhere from 5-8 min to complete but eventually will perform the blob coloring. 

For computing the statistics, I iterated through the region list that was passed. To get the total list of pixels that belong to a region, I created a dictionary for the region then used the region number itself as an index and appended the pixel coordinate belonging to that region. I also kept a running sum of the x-coordinates and the y-coordinates for that region to help in calculating the centroid. I also kept a count of the number of areas/regions total in the image to aid in interating values. Then I printed the statistics and also kept a stats dictionary to be passed on. The calculate the centroid, I took the sums of the x-coordinates and the y-coordinates I kept track of earlier and divded it by the area (which is the total number of pixels in the polygon). To help with iterating through the values and to keep track of which index in stats belongs to what region, I used a separate index outside of the for loop to iterate through stats_dict and incremented it after each part of the region's stat was printed and appended. I also had to have a separate counter to print the region as using the increment in the for loop sometimes printed large numbers in case the count range was high while iterating through the dictionaries. 

To mark the regions, I iterated through the count which is the length of the stats list passed divided by 3 (since each region has 3 values associated with it: area, x-coordinate of centroid, y-coordinate of centroid). To write each value to the image or indicate the coordinate of where the text should be written to the image, I iterated through the stats list the same way I appended to it in compute_statistics: by keeping a separate count outside of the foor loop and incrementing the count after extracting the value I need for the current region. For the fontsize, I had to scale it according to the height so it wasn't super big with one size and too small with another. I also had to switch the width and height to get the centroids marked in the right places. The only issue I could not ammend was if writing the text on the image goes beyond the image width, it disappears as I could not get the image width to expand so the value could be seen in the ouput image.  
=======
# Report
>>>>>>> 0f4dda1d1ede9d8db92d4195d4ef3f1b14912f91
